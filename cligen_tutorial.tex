\documentclass[a4paper, 10pt] {article}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage[parfill]{parskip}

\pagestyle{fancyplain}
%
% Title
%
\title {CLIgen Manual\\ {\small CLIgen version 3.4}}

\author{Olof Hagsand}
%
% Go!
%

\begin{document}

% rnr logo
% \lhead{\includegraphics[height=9mm]{../../doc/logga_crop.png}}
\date{June, 2013}
\maketitle
\setcounter{tocdepth}{2}
\tableofcontents
\newpage
\section{Introduction}
\label{sec:intro}

CLIgen builds interactive syntax-driven \emph{command-line interfaces}
in C from a high-level syntax specification. Interactive CLIs are
often used in communication devices such as routers and
switches. However, any devices with a textual, syntax-driven,
command-based interface can use CLIgen to make CLI programming easy.

CLIgen takes a syntax specification as input, generates a tree
representation of the syntax, and provides an interactive command-line
tool with completion, help, modes, etc.

A designer formulates the command-line syntax and writes callback
functions in C to implement the semantics of the commands.

A good starting point is the hello world example with a simple syntax
specification ("hello world") and a callback with a print statement,
which produces the following CLI executable:

\begin{verbatim}
  > ./cligen_hello 
  hello> hello world 
  Hello World!
  hello> 
\end{verbatim}

The complete {\tt cligen\_hello} C application is included in the
source code distribution.

\begin{figure}
\centering
\includegraphics[scale=0.8]{usage.pdf}
\caption{\em CLIgen usage: a designer implements a CLI by specificying the syntax in a specification file and the CLI source code using the CLIgen API.}
\label{fig:usage}
\end{figure}

Figure~\ref{fig:usage} shows a typical workflow when working with
CLIgen. A designer specifies the CLI syntax by editing a CLIgen
specification file and writing a C-program. When users access the CLI
at runtime, the specification file is loaded and the CLI uses the API
of the CLIgen library to interpret the commands.

An example of a CLIgen specification file of the hello world application is:
\begin{verbatim}
  prompt="hello> "             # Assignment of prompt
  hello("Greet the world"){    # 'hello' command with help text
    world, cb("Hello World!"); # 'world' command with callback
  }
\end{verbatim}

The specification above shows examples of the following key ingredients of a specification:
\begin{itemize} 
\item
\emph{Command syntax} specifies the syntax of the actual commands, and
are the main part of a specification. The command syntax is fully
described in Section~\ref{sec:syntax}.
\item
\emph{Callbacks} are functions called when a command has been entered
by a user. You may specify an argument to a callback. Callbacks
are a part of the API described in Section~\ref{sec:api}.
\item
\emph{Assignments} are used to set properties of the CLI and its
commands, such as prompts, modes authorization, visibility,
etc. Assignments are either global or per-command.
\item
\emph{Help text} provides help text for individual commands.
\item
\emph{Comments} begin with the '\#' sign.
\end{itemize}

The following sections will describe all aspects of designing CLIgen
application. Programming using the CLIgen API in C is described in
Section~\ref{sec:api}.

\section{Command syntax}
\label{sec:syntax}

The command syntax consists of a combination of keywords, variables and
operators:
\begin{itemize}
\item
\emph{Keywords} are constant strings representing fixed command words.
\item
\emph{Variables} are placeholders for user-defined input.
\item
\emph{Operators} are used to combine keywords and variables in different ways. Operators
include 'choice', 'option', 'sequence', etc. Operators are further described in Section~\ref{sec:operators}.
\end{itemize}

For example, the command syntax {\tt ip tcp <int>;} have two keywords:
{\tt ip}, and {\tt tcp} and one variable: {\tt <int>}. They are
combined in a \emph{sequence}, that is, the CLI expects them to be
typed one after the other.

\subsection{Keywords}

The simplest syntax consists only of keywords. Such a syntax can be
specified as follows:
\begin{verbatim}
  aa bb{
    ca;
    cb;{
      dd;
      ee;
    }
  }
  ff;
\end{verbatim}
A CLI loaded with the specification above accepts the following strings as input:
\begin{verbatim}
  aa bb ca
  aa bb cb
  aa bb cb dd
  aa bb cb ee
  ff
\end{verbatim}
Note the following:
\begin{itemize}

\item Newlines are not significant, except after comments. This means
  that another way of specifying the syntax above is: {\tt aa
    bb\{ca;cb;\{dd;ee;\}\}ff;}.

\item Keywords specified one after another is a
  sequence. Example: {\tt aa bb;}. An alternative of expressing the same syntax is: {\tt aa\{bb;\}}

\item Semicolon terminates a complete command. This means that {\tt aa bb cb}
 is accepted as a complete command, but not {\tt aa bb} in the syntax above.

\item Semicolons also act as a choice, you can choose either {\tt dd}
  or {\tt ee} in the syntax above.

\item Keywords can also be specified using variables: {\tt
  <string keyword:aa>}, there are some advantages with this which may
  get apparent when programming using the API (see
  Section~\ref{sec:api}).

\item The syntax above can be written in a more compact way, such as {\tt aa bb (ca|cb [dd|ee]);ff;}. This is described more in Section~\ref{sec:operators}

\end{itemize}

\subsection{Runtime behaviour}

A CLI with the syntax above will present the user with a list of
commands. On the top-level, only {\tt aa} or {\tt bb} may be chosen when a question mark is entered:
\begin{verbatim}
  > '?'
    aa
    gg
\end{verbatim}

If the user prints an 'a', followed by a 'TAB', the CLI performs
completion to {\tt aa} since there is only one alternative:
\begin{verbatim}
  > a'TAB'
  > aa 'TAB'
  > aa bb 'TAB'
  > aa bb c'TAB'
  ca                  cb
  > aa bb c
\end{verbatim}
In the example, two more {\tt TAB}s are entered, one for each command
level and completion continues until the commands are not unique. In
the last {\tt TAB}, the CLI shows the available commands ({\tt ca} and {\tt cb}).

As long as a command is unique it is not necessary to
complete the whole string. For example, the following two strings are
equivalent from the CLIs perspective:
\begin{verbatim}
  > aa bb cb dd
  > a b cb d
\end{verbatim}

Before finishing a command (with return), a unique
command must be selected. The CLI gives an error code if the command
is unknown, ambiguous or incomplete:
\begin{verbatim}
> a
CLI syntax error in: "a": Incomplete command
> aa bb c
CLI syntax error in: "aa bb c": Ambigous command
> aa bb dd
CLI syntax error in: "aa bb dd": Unknown command
\end{verbatim}

\subsection{Help texts}

Help texts are given within parenthesis following a keyword or
variable. The help text appears when you invoke the help command '?'
in the CLI runtime.

For example, assume the following syntax:
\begin{verbatim}
  ip("The IP protocol"){
    udp("The UDP protocol") <ipaddr>("IPv4 address");
    tcp("The TCP protocol") <int>("Port number");
  }
\end{verbatim}
If a user has typed 'ip ' and '?', the following help text appears:
\begin{verbatim}
cli> ip '?'
  tcp                      The TCP protocol
  udp                      The UDP protocol
\end{verbatim}

\subsection{Callbacks}
\label{sec:callbacks}

When a unique command has been selected, a callback may be
called. Callbacks are typically associated with commands using the
file syntax:
\begin{verbatim}
  aa bb{
    ca,fn1("ca");
    cb,fn1("cb");{
      dd,fn2();
      ee,fn3((int)42);
    }
  }
\end{verbatim}

In the example, the function {\tt fn1} is called with {\tt "ca"} as
argument if {\tt aa bb ca}, is selected. The same function is called
also if {\tt aa bb cb} is selected, but with another argument. For
other commands, {\tt fn2} is called without argument, and {\tt fn3} is
called with the integer argument {\tt 42}.

Note that callbacks may only be associated with terminal commands. For
example, {\tt aa bb} may not have a callback function.

The details on how to write callback functions, such as {\tt fn1} -
{\tt fn3} is described in detail in Section~\ref{sec:api}.

\subsection{Assignments}
\label{sec:assignments}

You can assign values to \emph{global} and \emph{local}
variables. Global variables are valid for the whole syntax, while
local variables only apply to a single command.

\subsection{Local assignments}
At this point, there are two pre-defined local variables: 
\begin{itemize}
\item
{\tt hide} specifies that a command is not visible when listing or
completing commands with '?' and 'TAB'.  Still, the command is
selectable and may be selected if you type it. This can be useful if there are
commands that should be known only by expert users.
\item
{\tt auth}.  defines authorization level the user should have to be
able to use the command.
\end{itemize}

In the following example, {\tt aa bb ca} is not visible,
whereas {\tt aa bb cb} and {\tt aa bb cb dd} are only shown if the
user has {\tt show commands} priviligies.
\begin{verbatim}
  aa bb{
    ca,hide;
    cb,auth="show";{
      dd,auth="show";
      ee;
    }
  }
\end{verbatim}

\subsection{Global assignments}
Typical examples of global variables are {\tt comment}, {\tt prompt}
and {\tt mode}.  Technically, they are not predefined but are easy to
implement and the first two are supported by the tutorial
application. We already saw an example of the usage of {\tt prompt} in
the hello world example in Section~\ref{sec:intro}.

Here is another example of two specifications in two separate files which are loaded into
the same CLI:
\begin{verbatim}
Spec1:
  prompt="m1> ";
  comment="%";
  mode="mode1";
  change mode,mode("mode2");
\end{verbatim}
\begin{verbatim}
Spec2:
  prompt="m2> ";
  comment="!";
  mode="mode2";
  change mode,mode("mode1");
\end{verbatim}
The syntax specifies two different modes with different prompts, both
with a single command ({\tt change mode}) which simply changes
mode. The {\tt comment} variable specifies which character identifies a comment in the CLI\footnote{Note that this separate from a comment in a CLIgen \emph{specification}.}

An example run of this CLI is:
\begin{verbatim}
  m1> '% this is a comment'
  m1> 'change mode'
  m2> '?'
       change
  m2>
\end{verbatim}

Note that the {\tt mode} callback needs to be implemented as a
callback function in C to actually change the syntax mode, see
Section~\ref{sec:api}.

\subsection{Tree references}

A syntax may reference another sub-tree, or even itself (recursion), using the 'reference operator '@'.

The following specification references itself:
\begin{verbatim}
name="T";
foo;
recurse @T;
\end{verbatim}
which means that the following sentences are valid commands:
\begin{verbatim}
foo
recurse foo
recurse recurse foo
recurse recusre recurse foo
\end{verbatim}
and so on.



\section{Variables}
\label{sec:variables}
Variables are placeholders for user input. They also give support for
limited lexical checking. The {\tt number} type, for example, only
accepts integers, while {\tt string} accepts any sequence of
characters. Variables have names and types, and can be composed into more
advanced constructions.

\subsection{String}
The simplest form of a string specification is: {\tt
<string>}, which defines a string variable with the name 'string'.

A more advanced string variable specification is the following:
\begin{verbatim}
  address <addr:string>("Address to home");
\end{verbatim}
where the name of the string variable is {\tt addr}. The name can be used when referring to the variable in a callback, and is also used in the help text:
\begin{verbatim}
  cli> address '?'
     addr          Address to home
\end{verbatim}

A string may contain all characters with some minor exceptions. Most
notably, a string can not contain a question mark, since it is used
for querying syntax in the CLI.  Also, if a string contains spaces, it
must be contained within double quotes.  The following examples are all valid
strings:
\begin{verbatim}
  i_am_a_string
  ()/&#
  "I am a string"
  ab"d
\end{verbatim}

A variant of string is {\tt rest} which accepts all characters until
the end-of-line. 

\subsection{Number}
The {\tt number} variable allows any 32-bit integer, and can be specified in decimal
or hex format. 

Examples:
\begin{verbatim}
  <age:number>
  <age:number range [18:999]>
\end{verbatim}

The second form only accepts integers in the specified
range, such as: "77" and "0x20".

A variant of number is {\tt long} which is a 64-bit integer.

\subsection{Addresses}

CLIgen is often used in communication devices. Therefore, there is
support for several pre-defined address types.  Special lexical
checking is defined for those types:

\begin{itemize}
\item {\tt ipv4addr} - An IPv4 address in dotted decimal notation. Example: {\tt 1.2.3.4}
\item {\tt ipv4prefix} - An IPv4 prefix in 'slash' notation: Example: {\tt 1.2.3.0/24}
\item {\tt ipv6addr} - An IPv6 address. Example: {\tt 2001::56}
\item {\tt ipv6prefix} - An IPv6 prefix. Example: {\tt 2001:647::/64}
\item {\tt macaddr} - A MAC address: Example: {\tt 00:E0:81:B4:40:7A}
\item {\tt url} - An URL: Example: {\tt http://www.hagsand.se/cligen}
\end{itemize}

CLIgen performs lexical checking of the address variables, an invalid
address is considered as a syntax error.

\subsection{Uuid}

A variable of type {\tt uuid} accepts uuid according to standard syntax,
such as {\tt f47ac10b-58cc-4372-a567-0e02b2c3d479}. 


\subsection{Time}

A {\tt time} variable accepts ISO timestamps on the form

\begin{verbatim}
  2008-09-21T18:57:21.003456
  2008-09-21 18:57:21.003456
  2008-09-21 18:57:21
\end{verbatim}

\subsection{Boolean}

A variable of {\tt bool} type accepts the values {\tt true}, {\tt
  false}, {\tt on} and {\tt off}.

\subsection{Keyword}
\label{sec:keyword}

A keyword variable is just an alternative way of specifying command
keywords as defined in Section~\ref{sec:syntax}. In fact, a syntax
with static keywords can just as well be written using keyword
variables. 

Thus, for example, the two specification lines below are equivalent:
\begin{verbatim}
  aa bb;
  <aa:string keyword:aa> <bb:string keyword:bb>;
\end{verbatim}

However, a keyword variable can have another name:
\begin{verbatim}
  <myname:string keyword:aa>;
\end{verbatim}

Naming of keywords provides for more flexible search functions
in callbacks, see Section~\ref{sec:api}.

Note that a keyword must be of type {\tt string}.

\subsection{Choice}

The choice variable can take the value from a static list of elements.

Example:
\begin{verbatim}
  interface <ifname:string choice:eth0|eth1>("Interface name")
\end{verbatim}

A CLI user will get the following choice:
\begin{verbatim}
  cli> interface '?'
     eth0        Interface name
     eth1        Interface name
  cli> 
\end{verbatim}
The user can only select eth0 or eth1, and thus the value of the {\tt
  ifname} variable is either {\tt eth0} or {\tt eth1}.

Note the resemblance with choice of strings in
Section~\ref{sec:operators} where the same example could be specified
as:
\begin{verbatim}
  interface (eth0|eth1)
\end{verbatim}

Again, the former variant allows for naming of the variable which can
be better when writing a callback function. In the example, the name
of the variable in the first example is {\tt ifname} whereas in the
second it is \emph{either} {\tt eth0} or {\tt eth1}.

\subsection{Expand}
\label{sec:expand1}
The choice variable specifies a static list of
keywords. But what if the list is dynamic and changes over time?

The expansion variable is a \emph{dynamic} list of keywords, where the
list may be different each time the CLI command is invoked.

For example, assume a user can select a network interface in the CLI,
but the number of interfaces changes all the time. This can be
specified as follows:

\begin{verbatim}
  interface <ifname:string interfaces()>("Interface name")
\end{verbatim}
The user's choice in the CLI will then be just as in the choice case:
\begin{verbatim}
  cli> interface '?'
     eth0        Interface name
     eth1        Interface name
  cli> 
\end{verbatim}

However, at another point in time, the choice of interfaces may be different:
\begin{verbatim}
  cli> interface '?'
     eth3        Interface name
     lo0         Interface name
  cli> 
\end{verbatim}

There is one catch here: the CLI needs to know in run-time the members
of the list. That is, the list members cannot be specified in the
syntax.  In CLIgen, the application programmer defines a C callback
function, {\tt interfaces()} in this example, which computes the list
at the time it is needed. This callback is registered and called
whenever necessary.

How to write an expand callback is further described in
Section~\ref{sec:expand}.

\subsection{Regular expressions}

A string variable may be described using a regular expression. That
is, a regular expression defines which values are valid. 

For example, a variable may be specified as:
\begin{verbatim}
  <name:string regexp:"(ab|a)b*c">;
  <name:string regexp:"[a-z]+[0-8]+\\.[0-9]">;
\end{verbatim}
The first rule matches the following strings, for example:
\begin{verbatim}
ac
abc
abbbbbbbbbc
\end{verbatim}
CLIgen uses POSIX Extended regular expression syntax.

\section{Operators}
\label{sec:operators}

I the regular syntax format, there are (implicit) sequence and choices. For example, the syntax
\begin{verbatim}
  aa bb;
  cc;
\end{verbatim}
defines a choice between the sequence {\tt aa bb} and {\tt cc}.

It is also possible to explicitly define choices, optional elements and syntactical groupings.

\subsection{Choice and grouping}
Explit choice between several elements can be made as follows:
\begin{verbatim}
  (aa bb) | cc;
\end{verbatim}
which expresses the same syntax as above.

Help strings work as usual, but may \emph{not} be associated with
groupings:
\begin{verbatim}
  aa (bb("help b") cc("help c") | dd("help d"));
\end{verbatim}

Choices may also be made with variables:
\begin{verbatim}
  values (<int> | <string> | <long> | aa);
\end{verbatim}

where a pattern matching is made selecting to try to select the most 'specific'
variable. For example, the following input will give different matchings:
\begin{itemize}
\item
{\tt aa} selects the keyword.
\item
{\tt bb} selects {\tt <string>}.
\item
{\tt 42} selects {\tt <int>}.
\item
{\tt 324683276487326} selects {\tt <long>}.
\end{itemize} 

\subsection{Optional elements}
It is also possible to express an \emph{optional} part of a syntax
using brackets:
\begin{verbatim}
  aa [[bb] cc];
\end{verbatim}
which accepts the commands: {\tt aa}, {\tt aa bb} and  {\tt aa bb cc}.

Any combination of these operations are possible, such as in the line:
\begin{verbatim}
  aa [[(bb|cc <int>)] dd] ee;
\end{verbatim}

Note that the elaborate command specifications above can be combined
in a regular syntax, at parsing they are just expanded into a larger
syntax tree. 
Thus for example, the syntax:
\begin{verbatim}
  aa bb (ca("help ca")|cb("help cb")) [dd|ee];
\end{verbatim}
is equivalent to:
\begin{verbatim}
aa bb{
   ca("help ca");{
      dd;
      ee;
   }
   cb("help cb");{
      dd;
      ee;
   }
}
\end{verbatim}
which is similar to the syntax used in Section~\ref{sec:syntax}.

\section{API}
\label{sec:api}
This section describes C-programming issues, including types, parsing and
callbacks.

Appendix A contains a complete program illustrating many of the topics
of this tutorial.  More advanced applications can be found in the CLIgen
source repository.

\subsection{CLIgen variables}

Variables in the command syntax (such as {\tt <string>}) described in
Sections~\ref{sec:variables} and \ref{sec:assignments} are translated
in runtime into \emph{CLIgen variables} using the {\tt cg\_var}
datatype.  A CLIgen variables is sometimes referred to as a \emph{cv}.

A cv is a handle and its values are accessed using get/set
accessors. Two generic fields are {\tt name} and {\tt type}, other
fields are accessed via type-specific accessors (see next Section).

Example: get name and type of cligen variable:
\begin{verbatim}
  char *name        = cv_name_get(cv);
  enum cv_type type = cv_type_get(cv);
\end{verbatim}


\subsubsection{Types}

CLIgen variables have a simple type-system, essentially following the
types introduced in Section~\ref{sec:variables}. Each cv type
have get/set operators to access and modify the value.

For example, a command syntax contains {\tt <addr:ipv4addr>}, and
the user inputs "12.34.56.78". The CLI will then generate a cv which
can be accessed in C. The string
"12.34.56.78" is accessed with:
\begin{verbatim}
  struct in_addr addr = cv_ipv4addr_get(cv);
\end{verbatim}

Accessors for other types are shown in the table
below. There may be several fields for a given type. These are given
in the table with the corresponding C-type.

\begin{tabular}{ | l | l | l | }
\hline
  \textbf{ Type} & \textbf{Accessor} & \textbf{C-type}\\
\hline
number & {\tt cv\_int\_get()} & {\tt int32} \\
long & {\tt cv\_long\_get()} & {\tt int64} \\
bool & {\tt cv\_bool\_get()} & {\tt char} \\
string & {\tt cv\_string\_get()} & {\tt char*} \\
ipv4addr   & {\tt cv\_ipv4addr\_get()} & {\tt struct in\_addr}\\
ipv4prefix & {\tt cv\_ipv4addr\_get()} & {\tt struct in\_addr}\\
           & {\tt var\_ipv4masklen\_get()} & {\tt uint8}\\
ipv6addr   & {\tt cv\_ipv6addr\_get()} & {\tt struct in6\_addr}\\
ipv6prefix & {\tt cv\_ipv6addr\_get()} & {\tt struct in6\_addr}\\
           & {\tt var\_ipv6masklen\_get()} & {\tt uint8}\\
macaddr    & {\tt cv\_mac\_get()} & {\tt char[6]}\\
uuid       & {\tt cv\_uuid\_get()} & {\tt char[16]}\\
time       & {\tt cv\_time\_get()} & {\tt struct timeval}\\
url        & {\tt cv\_urlproto\_get()} & {\tt char*}\\
           & {\tt cv\_urladdr\_get()} & {\tt char*}\\
           & {\tt cv\_urlpath\_get()} & {\tt char*}\\
           & {\tt cv\_urluser\_get()} & {\tt char*}\\
           & {\tt cv\_urlpasswd\_get()} & {\tt char*}\\
\hline
\end{tabular}

You may also access a value with an unspecified type using:
\begin{verbatim}
  void *v = cv_value_get(cv);
\end{verbatim}


\subsubsection{Cligen variable vectors}
Variables are grouped into vectors whose using {\tt cvec}. Global variables or variables
passed to callback functions are always grouped into {\tt cvec}
structures.




\subsubsection{Finding variables in a vector}
\label{sec:find}



Suppose for example that you have the following command syntax:
\begin{verbatim}
person [male|female] (<age:number>|<name:string>)
\end{verbatim}

A {\tt cvec} is accessed using a handle. Typically an iterator is used to access the individual cv:s within a vector:
\begin{verbatim}
   cvec *vr;
   cg_var *cv = NULL;
   while ((cv = cvec_each(vr, cv)) != NULL) {
      str = cv_name_get(cv);
   }
\end{verbatim}

You can also access the variables individually if you know their order, in this example the 3rd element:
\begin{verbatim}
   cvec *vr;
   cg_var *cv = cvec_i(cv, 2);
\end{verbatim}

A way to find variables using their names is as follows:
\begin{verbatim}
  cg_var *cv = cvec_find(vars, "age");
\end{verbatim}

Actually, kewords are also a part of variable vectors. This means that
they can also be accessed via their name, although the name of the
keyword is the same as its constant value, as described in
Section~\ref{sec:keyword}.

Therefore, you can also check whether a keyword exists or not. Using the same example:
\begin{verbatim}
  if (cvec_find(vars, "male") != NULL)
    printf("male\n");
\end{verbatim}
where the conditional evaluates to true only if the user has selected
{\tt male} and not {\tt female}.

\subsection{Initializing}
\label{sec:handle}

An application calls the CLIgen init function to initialize the CLIgen
library.  The function returns a {\tt handle} which is used in most
CLIgen API functions.

In the following example, CLIgen is initialized, a prompt is set, and
is then terminated:
\begin{verbatim}
  cligen_handle h = cligen_init();
  cligen_prompt_set(h, "cli> ");
  [...]
  cligen_exit(h);
\end{verbatim}

\subsection{Parsing syntax files}
\label{sec:parsing}
The command syntax as described in
Sections~\ref{sec:syntax}-\ref{sec:operators} normally resides in a
file which is loaded and parsed by the CLI. The result of the parsing
is a parse-tree and a list of global variable assignment. After
parsing, the program needs to interpret the result and set up the CLI
environment. This includes handling global variable assignments,
mapping function callbacks, etc. 

Most non-trivial programs handle many syntaxes that are merged into a
common parse-tree, while others partition parse-trees into different
modes.

An example of parsing syntax file {\tt mysyntax.cli} is the following: 
\begin{verbatim}
  cligen_handle h;
  FILE         *f;
  parse_tree    pt;
  varrec        globals;

  h = cligen_init();
  f = fopen("mysyntax.cli");
  cligen_parse_file(h, f,  "mysyntax", &pt, &globals) < 0)
  cligen_tree_add(h, "mymode", pt);
  cligen_mode_set(h, "mymode");
\end{verbatim}

The example code initiates a handle, opens the syntax file, parses the
syntax into the parsetree {\tt pt} and a list of global variable
assignments in {\tt globals}. It also registers the parse tree and sets it to 
be the active mode used in the CLI. 

The next step is to handle the global variables and to bind callback
functions.

\subsection{Global variables}

In the example, the {\tt global} variable contains the list of global
CLIgen variables.  In the followung example, the prompt and comment
sign are found in the list:
\begin{verbatim}
  char *prompt;
  char *comment;

  prompt = cvec_find_str(globals, "prompt");
  if ((comment = cvec_find_str(globals, "comment")) != NULL)
    cligen_comment_set(comment[0]);
\end{verbatim}

In the example above, there are two further examples of CLIgen API library calls: 
\begin{itemize}
\item
{\tt cvec\_find\_str} a specialization of {\tt cvec\_find} decribed in Section~\ref{sec:find} finds the value of a string variable.  Note that the prompt needs to be sent along with {\tt cligen\_eval} as described in Section~\ref{sec:main}.
\item
{\tt cligen\_comment\_set} sets the comment character in the CLI.
\end{itemize}

In this way a programmer may define the semantics of global variables
by binding their value to actions.

\subsection{Command loop}
\label{sec:main}
When the syntax is specified, a simple command loop is written to
process commands and call loopbacks.
Example:
\begin{verbatim}
 for (;;){
     retval = cliread_eval(h, &line, &ret);
\end{verbatim}
The return value of the {\tt cliread\_eval} function is as follows:
\begin{itemize}
\item {\tt CG\_EOF}: end-of-file
\item {\tt CG\_ERROR}: CLIgen read or matching error, typically if the syntax is not well-defined.
\item {\tt CG\_NOMATCH}: No match, the input line did not match the syntax. By calling {\tt cligen\_nomatch(h)}, the reason for why no match was made is retrieved.
\item {\tt CG\_MATCH}: Match, the line matched exactly one syntactic node. The variable {\tt ret} contains the return value of the callback (if any).
\item $> 1$: Multiple matches, the line matched several syntax lines.
\end{itemize}

\section{Advanced API}

\subsection{Writing a callback function}

A programmer may write a callback function for every complete command
defined in the command syntax. Such a callback is then called every
time a user types that command in the CLI.

An example of {\tt CLIgen} callback function from the example in
Section~\ref{sec:intro} with the command syntax {\tt hello world,cb("hello");}is:

\begin{verbatim}
  int 
  cb(cligen_handle h, cvec *vars, cg_var *arg)
  {
    printf("%s\n", arg->var_string);
    return 0;
  }
\end{verbatim}
The callback returns zero if everything is OK, and $-1$ on error. The arguments of a callback
function are:
\begin{itemize}
\item
{\tt handle} - CLIgen handle created by a call to {\tt cligen\_init}. The handle is used if the callback makes API calls to CLIgen, such as changing prompt, parse-tree, etc.
\item
{\tt vars} - The command line as a list of CLIgen variables. Both keys and variables are included in the list.
\item
{\tt arg} - A single CLIgen variable declared in the command syntax.
\end{itemize}

Regarding a more advanced command syntax from Section~\ref{sec:find}:
\begin{verbatim}
  person [male|female] (<age:number>|<name:string>),cb("person");
\end{verbatim}
and an CLI input command such as:
\begin{verbatim}
  cli> person male 67
\end{verbatim}

The cligen variable vector {\tt vars} has four elements and can be accessed via iteration or via the {\tt cvec\_i()} function:
\begin{enumerate}
\item The complete command string: {\tt person male 67}.
\item The is a CLIgen string variable containing the keyword {\tt person}.
\item The keyword {\tt male}.
\item A CLIgen integer variable containing 67.
\end{enumerate}

The {\tt arg} argument contains the function argument in the command syntax: {\tt person}.

By using the values in the argument and variable vector, the callback
can perform actions by calling CLIgen API functions. In those
functions, the handle {\tt h} is usually required and used to make
global changes. 

\subsection{Registering callbacks}

A typical syntax contains callback references, such as the following:
\begin{verbatim}
  hello world, callback("arg");
\end{verbatim}

The parse-tree created in Section~\ref{sec:parsing} contains the
function names as strings which need to be mapped to function
pointers. This is a typical issue with the C programming language. The
problem is essentially the same as finding functions in a
symbol-table. Note that this mapping is not a part of CLIgen itself
but needs to be made by the application.

There are many ways to solve this issue, including using dynamic
libraries and making a lookup in real-time using {\tt dl\_open}, {\tt
  mmap}, or similar C library functions. This is actually the
preferred option, the other approaches described here are not as good.

The simplest way used in this tutorial is to map all callbacks to the
same function:
\begin{verbatim}
  cligen_callback_register(pt, callback);
\end{verbatim}
It is then up to {\tt callback} to determine
in which context it was called using its arguments.

A better way is to map each callback specified to a different
function. This can be made by defining a function that maps between
function name strings and actual functions and calling a mapping
funtion, for example:
\begin{verbatim}
  cg_fnstype_t *
  mapper(char *name, void *arg, char **error)
  {
    *error = NULL;
    if (strcmp(name, "callback") == 0)
      return callback;
    return callback; /* allow any function (for testing) */
  }

  cligen_callback_str2fn(pt, mapper, NULL);
\end{verbatim}

\subsubsection{Multiple callbacks}
Several callbacks may be associated with a syntax. Example:
\begin{verbatim}
  hello world, callback("arg"), extra();
  hello world, extra2();
\end{verbatim}
In this case, all three functions: {\tt callback}, {\tt extra} and {\tt extra2} are called, one after the other.

\subsection{Expansion}
\label{sec:expand}

If expand variables (see Section~\ref{sec:expand1}) are used, the
application defines a callback to fill in the elements of the dynamic
list. Such a callback is invoked every time the CLI asks for a command
containing the corresponding expand variable. That is, the callback
may be invoked when a user types a question mark or a TAB as well.

The following example shows the expand function {\tt
  expand\_ifname}. It is registered before the main loop and supplies
a list of pointers to strings, in this example a list of
interfaces. The example returns a static list of interfaces: "eth0"
and "eth1", a real example would dynamically get the list of
interfaces. If the helptexts are not given, the helptext in the specification is used.


\begin{verbatim}
  int 
  expand_ifname((cligen_handle h, char *name, cg_var *arg, 
                int *nr, char ***commands, char ***helptext)
  {
    *commands = calloc(2, sizeof(char*)); 
    *comments = calloc(2, sizeof(char*)); 
    (*commands)[0] = strdup("eth0");
    (*helptext)[0] = strdup("The 1st interface");
    (*commands)[1] = strdup("eth1");
    (*helptext)[1] = strdup("The second interface");

    *nr = 2;
    return 0;
  }

  main()
  {   
    [...]
    cligen_parse_file(h, f,  "mysyntax", &pt, &globals) < 0)
    if (cligen_expand_register(pt, expand_ifname) < 0)
      return -1;
    [...]
  }
\end{verbatim}

In other words, as soon as the user selects a line containing the
variable {\tt interfaces}, {\tt expand\_ifname()} will be
called. Therefore, be careful to avoid blocking calls within the
callbacks since this may make the CLI less interactive.

\section{Installation}

In a source release, CLIgen comes with a configuration script and
makefiles. Just unpack the source, configure it and type make, and try
the tutorial program:

\begin{verbatim}
  > tar xzf cligen.tgz
  > cd cligen
  > ./configure
  > make
  > sudo make install
  > ./cligen_tutorial -f tutorial.cli
  hello>
\end{verbatim}

CLIgen can be installed on a variety of platforms using
configure. Installation installs library and include files in the
system. It is also possible to install library only (or include-files
only) using {\tt make install-lib} (or {\tt make install-include}).

\normalsize
Some configure options are:
\begin{itemize}
\item {\tt --prefix} Change root installation directory. Deafult is {\tt /usr/local}.
\item {\tt --with-cc} Change C-compiler. 
\item {\tt --with-copt} Set C-compiler options. Defalt is {\tt -O2}.
\item {\tt --with-cflags} Set C-compiler flags. Defalt is {\tt -Wall -Werror -x c}.
\end{itemize}


\newpage
\section*{Appendix A: Tutorial command syntax}
\label{app:syntax}

This appendix contains an example command syntax. Most of it has
appeared in the tutorial. This example is found in the file {\tt
  tutorial.cli} in the source release.

\small
\begin{verbatim}
  # This file is part of CLIgen.
  # $Id: cligen_tutorial.tex,v 1.27 2013/07/02 05:47:50 olof Exp $
  # Copyright (C) 2011-2013 Olof Hagsand

  prompt="hello> ";            # Assignment of prompt
  comment="#";                 # Same comment as in syntax
  namer="tutor";               # Name of syntax (used when referencing)
  hello("Greet the world"){    # 'hello' command with help text
    world, hello("Hello World!"); # 'world' command with callback
  }
  # Nested command using callback arguments to differentiate
  ip("The IP protocol"){       
    tcp("The TCP protocol") <int>("Port number"), cb("tcp");
    udp("The UDP protocol") <ipaddr>("IPv4 address"), cb("udp");
  }
  # Example of commands on several levels
  aa bb,cb();{              
    ff,cb();
  }
  # Example of complex variable matching
  values (<int> | <string> | <long> | aa), cb();
  # Complex syntax and callback argument handling
  aa bb (ca("help ca") <int>|cb("help cb")) [dd|ee], letters();
  # Expand example
  interface {
    <ifname:string interface()>,cb(); 
  }
  # Example of hidden command
  secret,hide,secret("message");        
  # Example of changing prompt
  change prompt <new:string>("New prompt"),setprompt(); 
  
  # Example of sub-tree reference (here recursion).
  recurse @tutorial;

   # Quit CLI
  quit("quit the CLI"),quit(); 
\end{verbatim}
\normalsize

\newpage
\section*{Appendix B: API functions}
\label{app:functions}

This appendix contains a list of cligen API functions. There are several more which may be found in examples and include files.
\small

{\tt cvec cvec\-\_\-new (int len)}\\*
\emph{Create and initialize a new cligen variable vector (cvec)}

{\tt cligen\_handle cligen\_init(void)}\\*
\emph{This is the first call the CLIgen API and returns a handle. }

{\tt int cligen\_exit(cligen\_handle h)}\\*
\emph{ This is the last call to the CLIgen API}

{\tt int cligen\_comment\_set(cligen\_handle h, char c)}\\*
\emph{ Set comment character.}

{\tt int cligen\_prompt\_set(cligen\_handle h, char *prompt)}\\*
\emph{ Set CLIgen prompt string.}

{\tt parse\_tree *cligen\_tree(cligen\_handle h, char *name)}\\*
\emph{ Get a parsetree, if name==NULL, return first parse-tree}

{\tt int cligen\_tree\_add(cligen\_handle h, char *name, parse\_tree pt)}\\*
\emph{ Add a new parsetree}

{\tt char* cligen\_tree\_active(cligen\_handle h)}\\*
\emph{ Get name of currently active parsetree.}

{\tt int cligen\_tree\_active\_set(cligen\_handle h, char *treename)}\\*
\emph{ Set currently active parsetree by name.}

{\tt int cligen\_completion(cligen\_handle h)}\\*
\emph{ Get completion mode}

{\tt int cligen\_completion\_set(cligen\_handle h, int mode)}\\*
\emph{ Set completion mode}

{\tt int cligen\_terminalrows(cligen\_handle h)}\\*
\emph{ Get number of displayed terminal rows.}

{\tt int  cligen\_terminalrows\_set(cligen\_handle h, int rows)}\\*
\emph{ Set number of displayed terminal rows.}

{\tt int cligen\_terminal\_length(cligen\_handle h)}\\*
\emph{ Get length of lines (number of 'columns' in a line).}

{\tt int  cligen\_terminal\_length\_set(cligen\_handle h, int length)}\\*
\emph{ Set length of lines (number of 'columns' in a line).}

{\tt int cligen\_tabmode(cligen\_handle h)}\\*
\emph{ Get tab-mode, }

{\tt int cligen\_tabmode\_set(cligen\_handle h, int mode)}\\*
\emph{ Set tab-mode, }

{\tt int cligen\_lexicalorder(cligen\_handle h)}\\*
\emph{ Get lexical matching order: strcmp (0) or strverscmp (1).}

{\tt int cligen\_lexicalorder\_set(cligen\_handle h, int n)/*! }\\*
\emph{ Set lexical matching order: strcmp (0) or strverscmp (1).}

{\tt int cligen\_ignorecase(cligen\_handle h)}\\*
\emph{ Ignore uppercase/lowercase or not}

{\tt int cligen\_ignorecase\_set(cligen\_handle h, int n)}\\*
\emph{ Ignore uppercase/lowercase or not}

{\tt cvec *cvec\_new(int len)}\\*
\emph{  Create and initialize a new cligen variable vector (cvec)}

{\tt int cvec\_free(cvec *vr)}\\*
\emph{ Free a cvec}

{\tt int cvec\_init(cvec *vr, int len)}\\*
\emph{ Initialize a cligen variable vector (cvec) with 'len' numbers of variables.}

{\tt int cvec\_reset(cvec *vr)}\\*
\emph{ Like cvec\_free but does not actually free the cvec.}

{\tt cg\_var *cvec\_next(cvec *vr, cg\_var *cv0)\\*
\emph{  Given an cv in a cligen variable vector (cvec) return the next cv.}

{\tt cg\_var *cvec\_add(cvec *vr, enum cv\_type type)}\\*
\emph{  Append a new cligen variable (cv) to cligen variable vector (cvec) and return it.}

{\tt int cvec\_del(cvec *vr, cg\_var *del)}\\*
\emph{  Delete a cv variable from a cvec.}

{\tt int cvec\_len(cvec *vr)}\\*
\emph{ return length of a cvec.}

{\tt cg\_var *cvec\_i(cvec *vr, int i)}\\*
\emph{ return i:th element of cligen variable vector cvec.}

{\tt cg\_var *cvec\_each(cvec *vr, cg\_var *prev)/*! }\\*
\emph{ Iterate through all cligen variables in a cvec list}

{\tt cg\_var *cvec\_each1(cvec *vr, cg\_var *prev)}\\*
\emph{ Like cvec\_each but skip element 0. }

{\tt cvec *cvec\_dup(cvec *old)}\\*
\emph{  Create a new cvec by copying from an original}

{\tt int cvec\_match(cg\_obj *co\_match, char   *cmd, cvec   *vr)}\\*
\emph{ Create cv list by matching a CLIgen parse-tree and an input string. }

{\tt int cvec\_print(FILE *f, cvec *vr)}\\*
\emph{ Pretty print cligen variable list to a file}

{\tt cg\_var *cvec\_find(cvec *vr, char *name)}\\*
\emph{ Return first cv in a cvec matching a name}

{\tt cg\_var *cvec\_find\_var(cvec *vr, char *name)}\\*
\emph{  Like cvec\_find, but only search non-keywords}

{\tt cg\_var *cvec\_find\_keyword(cvec *vr, char *name)}\\*
\emph{ Like cvec\_find, but only search keywords}

{\tt char *cvec\_find\_str(cvec *vr, char *name)}\\*
\emph{  Typed version of cvec\_find that returns the string value.}

{\tt int cv\_exclude\_keys(int status)}\\*
\emph{ Changes cvec find function behaviour, exclude keywords or include them.}

{\tt int cligen\_output(FILE *f, char *template, ... )}\\*
\emph{ CLIgen output function. All output should be made via this function.}

{\tt void cligen\_susp\_hook(cligen\_handle h, int (*fn)(void *h, char *, int, int *))}\\*
\emph{ Register a suspend (\^Z) function hook }

{\tt void cligen\_exitchar\_add(cligen\_handle h, char c)}\\*
\emph{ Register extra exit characters (in addition to ctrl-c)}

{\tt int cligen\_help(FILE *f, parse\_tree pt)}\\*
\emph{ Print top-level help (all commands) of a parse-tree}

{\tt int cov\_print(cg\_obj *co, char *cmd, int len, int brief)}\\*
\emph{ Print the syntax specification of a varible syntax spec}

{\tt int cligen\_print(FILE *f, parse\_tree pt, int brief)}\\*
\emph{  Print CLIgen parse-tree to file, brief or detailed.}

{\tt int cliread\_eval(cligen\_handle h, char **line, int *cb\_retval)}\\*
\emph{ Read line from terminal, parse the string, and invoke callbacks.}

{\tt int cligen\_parse\_str(cligen\_handle h, char *str, char *name, parse\_tree *pt, cvec *vr)}\\*
\emph{ Parse a string containing a CLIgen spec into a parse-tree}

{\tt int cligen\_parse\_file(cligen\_handle h, FILE *f, char *name, parse\_tree *pt, cvec *globals)}\\*
\emph{ Parse a file containing a CLIgen spec into a parse-tree}

{\tt int cligen\_callback\_register(parse\_tree pt, cg\_fnstype\_t *fn)}\\*
\emph{  Register (same) callback for all commands in a syntax.}

{\tt int cligen\_callback\_str2fn(parse\_tree pt, cg\_str2fn\_t *str2fn, void *fnarg)}\\*
\emph{  Register callback for commands using callback function}

{\tt char *cv\_name\_get(cg\_var *cv)}\\*
\emph{ Get name of cligen variable cv}

{\tt char *cv\_name\_set(cg\_var *cv, char *s0)}\\*
\emph{ allocate new string from original. Free previous string if existing.}

{\tt enum cv\_type cv\_type\_get(cg\_var *cv)}\\*
\emph{ Get cv type}

{\tt void *cv\_value\_get(cg\_var *cv)}\\*
\emph{ Get value of cv without specific type set}

{\tt char cv\_bool\_get(cg\_var *cv)}\\*
\emph{ Get boolean value of cv}

{\tt int32\_t cv\_int\_get(cg\_var *cv)}\\*
\emph{ Get integer value of cv}

{\tt int64\_t cv\_long\_get(cg\_var *cv)}\\*
\emph{ Get 64-bit integer value of cv}

{\tt char *cv\_string\_get(cg\_var *cv)}\\*
\emph{ Get pointer to cv string. }

{\tt char *cv\_string\_set(cg\_var *cv, char *s0)}\\*
\emph{ allocate new string from original. Free previous string if existing.}

{\tt struct in\_addr *cv\_ipv4addr\_get(cg\_var *cv)}\\*
\emph{ Get ipv4addr, pointer returned, can be used to set value.}

{\tt uint8\_t cv\_ipv4masklen\_get(cg\_var *cv)}\\*
\emph{ Get ipv4addr length of cv}

{\tt struct in6\_addr *cv\_ipv6addr\_get(cg\_var *cv)}\\*
\emph{ Get ipv6addr, pointer returned, can be used to set value.}

{\tt uint8\_t cv\_ipv6masklen\_get(cg\_var *cv)}\\*
\emph{ Get ipv6addr length of cv}

{\tt char *cv\_mac\_get(cg\_var *cv)}\\*
\emph{  Returns a pointer to 6-byte mac-address array. }

{\tt unsigned char *cv\_uuid\_get(cg\_var *cv)}\\*
\emph{ Returns a pointer to uuid byte array. }

{\tt struct timeval cv\_time\_get(cg\_var *cv)}\\*
\emph{ Returns a struct timeval by value.}

{\tt char *cv\_urlproto\_get(cg\_var *cv)}\\*
\emph{  Get pointer to URL proto string. }

{\tt char *cv\_urladdr\_get(cg\_var *cv)}\\*
\emph{  Get pointer to URL address string. }

{\tt char *cv\_urlpath\_get(cg\_var *cv)}\\*
\emph{  Get pointer to URL path string. }

{\tt char *cv\_urluser\_get(cg\_var *cv)}\\*
\emph{  Get pointer to URL user string. }

{\tt char *cv\_urlpasswd\_get(cg\_var *cv)}\\*
\emph{  Get pointer to URL passwd string. }

{\tt enum cv\_type cv\_str2type(char *str)}\\*
\emph{ Translate (parse) a string to a CV type.}

{\tt char *cv\_type2str(enum cv\_type type)/*! }\\*
\emph{ Translate (print) a cv type to a static string.}

{\tt int cv\_len(cg\_var *cv)}\\*
\emph{  Return length of cligen variable value (as encoded in binary)}

{\tt int cv2str(cg\_var *cv, char *str, size\_t size)}\\*
\emph{ Print value of CLIgen variable using printf style formats.}

{\tt char *cv2str\_dup(cg\_var *cv)}\\*
\emph{ Like cv2str, but allocate a string with right length.}

{\tt int cv\_print(FILE *f, cg\_var *cv)}\\*
\emph{ Pretty print cligen variable value to a file}

{\tt int cv\_parse1(char *str0, cg\_var *cv, char **reason)/*! }\\*
\emph{ parse cv from string. }

{\tt cv\_validate(cg\_var *cv, cg\_varspec *cs, char **reason)}\\*
\emph{  Validate cligen variable cv using the spec in cs.}

{\tt int cv\_cmp(cg\_var *cgv1, cg\_var *cgv2)}\\*
\emph{ Compare two cv:s}

{\tt int cv\_cp(cg\_var *new, cg\_var *old)}\\*
\emph{ Copy from one cv to a new cv.}

{\tt cg\_var *cv\_dup(cg\_var *old)}\\*
\emph{ Create a new cgv and copy the contents from the original. }

{\tt cg\_var *cv\_new(enum cv\_type type)}\\*
\emph{ Create new cligen variable. }

{\tt int cv\_reset(cg\_var *cgv)}\\*
\emph{ Free pointers and resets a single CLIgen variable cv}

{\tt int cv\_free(cg\_var *cv)}\\*
\emph{ Free a single CLIgen variable (cv) AND frees the cv itself}

\normalsize





\newpage
\section*{Appendix C: Control sequences}
\label{app:control}
The control sequences of the runtime CLI is as follows:


\begin{tabular}{ | l | l | l | }
\hline
  \textbf{ Control sequence} & \textbf{Action} & \textbf{Comment} \\
\hline
? & Help & \\
\hline
Ctrl + A & Go to beginning of line & \\
\hline
Ctrl + B & One char backwards & \\
\hline
Ctrl + C & Exit CLI & Add extra w cligen\_exitchar\_add().\\
\hline
Ctrl + D & End-of-file. & Exit if at beginning of line \\
\hline
Ctrl + E & Goto end of line & \\
\hline
Ctrl + F & One char forward & \\
\hline
Ctrl + H & Erase previous character & Backspace\\
\hline
Ctrl + I & Auto completion & TAB \\
\hline
Ctrl + K & Erase line after cursor & \\
\hline
Ctrl + L & Redraw line & \\
\hline
Ctrl + N & Move to next line in history & \\
\hline
Ctrl + O & Toggle overwrite mode & \\
\hline
Ctrl + P & Move to previous line in history & \\
\hline
Ctrl + R & Search history list backward & \\
\hline
Ctrl + S & Search history list forward & \\
\hline
Ctrl + T & Transpose character & \\
\hline
Ctrl + U & Erase line before cursor & \\
\hline
Ctrl + W & Erase word backward & \\
\hline
Ctrl + Y & Insert previously deleted text& 'yank' \\
\hline
Ctrl + Z & 'Suspend' & Register callback: \\&&cligen\_susp\_hook() \\
\hline
Arrow up & Move to previous line in history & \\
\hline
Arrow down & Move to next line in history & \\
\hline
Arrow left & One char backward & \\
\hline
Arrow right & Once char forward & \\
\hline
ESC + F & Move one word forward & \\
\hline
ESC + B & Move one word backward & \\
\hline
\end{tabular}



\end{document}
